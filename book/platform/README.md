# The OCaml Platform

Every language, no matter how elegant, also needs a set of tools for the
working programmer to deal with editing, compiling, testing, documenting and
publishing your source code. The OCaml community has adopted a platform of
modern tools that help you specify your project metadata and interface it with
IDEs (such as Visual Studio Code), to generate API documentation, and also to
adopt modern software engineering practises such as continuous integration (CI)
and fuzz testing.

Now that you are familiar with the core OCaml language, this second part of the
book will covers tools and techniques for using OCaml at a larger scale.  We
will begin by illustrating the typical structure for an OCaml project and how
you might get started.


## A Hello World OCaml Project

Let's start by creating a sample OCaml project and navigating around it.  opam
provides a project generator known as `spin` that can be used to create various
types of projects.

```sh dir=examples/correct/opam-spin-ls
$ opam spin ls

  bin
    Native project containing a binary

  c-bindings
    Bindings to a C library

  cli
    Command Line Interface releasable on Opam

  js
    Javascript application with Js_of_ocaml

  lib
    Library releasable on Opam

  ppx
    PPX library

```

Before we dive into any of these, we'll generate a tutorial using Spin's built-in
hello world project.

<!-- ```sh dir=examples/correct/opam-spin-hello
TODO need a way to stop spin from running the opam install commands
 -->

```
$ opam spin hello hello-world -vvv

🏗️  Creating a new project from hello in hello-world
Done!

🎁  Installing packages globally. This might take a couple minutes.
```

Spin will create a `hello-world` directory and populate it with a skeleton
OCaml project. Let's have a look around to see what has been generated.

<!-- ```sh dir=examples/correct/hello-world -->
```
$ ls -a
.gitignore
.ocamlformat
.rwo-example
LICENSE
Makefile
README.md
_build
bin
dune
dune-project
hello.opam
lib
test
```

Some of the files generated may be familiar to you from using other programming
languages:

- the `Makefile` contains targets for common actions such as `all`, `build`, `test`
  or `clean`.  It's useful to read through this to see which underlying OCaml tools
  are being invoked.
- the `LICENSE` defines the terms under which your code is made available, and
  defaults to the permissive ISC license.
- a `README.md` is a Markdown-formatted introduction to your library or application.
- the `.gitignore` file contains the patterns for generated files from the OCaml
  tools so that they can be ignored by the Git version control software.
  If you're not familiar with using Git, look over one of the tutorials
  one such as GitHub's [git hello world](https://guides.github.com/activities/hello-world/).

The only metadata file that is really _required_ to participate in
the OCaml ecosystem is an `opam` file in your source tree.  Each `opam`
file defines an *opam package* -- a collection of OCaml libraries and executable binaries or application
data.  Each package can define dependencies on other packages and includes
build and testing directions. Let's look at the `hello.opam` file we just created:

<!-- $MDX file=examples/correct/hello-world/hello.opam -->
```
# This file is generated by dune, edit dune-project instead
opam-version: "2.0"
synopsis: "A short description of the project"
description: "A short description of the project"
maintainer: ["Your name"]
authors: ["Your name"]
license: "ISC"
homepage: "https://github.com/username/hello"
doc: "https://username.github.io/hello/"
bug-reports: "https://github.com/username/hello/issues"
depends: [
  "ocaml" {>= "4.08.0"}
  "dune"
  "alcotest" {with-test}
  "odoc" {with-doc}
]
build: [
  ["dune" "subst"] {pinned}
  [
    "dune"
    "build"
    "-p"
    name
    "-j"
    jobs
    "@install"
    "@runtest" {with-test}
    "@doc" {with-doc}
  ]
]
dev-repo: "git+https://github.com/username/hello.git"
```

The fields in here all represent metadata that describes your project, ranging
from textual descriptions to project URLs to other opam package dependencies.
A collection of `opam` files can be stored in an
*opam repository* to create a package database, with a central one for the OCaml
ecosystem available at <https://github.com/ocaml/opam-repository>.
The official (but not exclusive) tool used for manipulating `opam` files is the
eponymous [opam package manager](https://opam.ocaml.org).  For the purposes of this
chapter, make sure you have a basic installation of opam on your system.

We can now use opam to install the dependencies required for our hello world project.

<!-- ```sh dir=examples/correct/hello-world -->
```
$ make deps
```

This will invoke the opam CLI to install the project dependencies and some useful
tools.  opam doesn't require any special user permissions and stores all of the 
files it installs in `~/.opam` (for global installations) and `_opam` in the
working directory for the project-local installations.  You can use `opam env`
to add the right directories to your local shell path:

```
$ eval $(opam env)
```

If you prefer not to modify your shell configuration, then you can also invoke
the build commands via `opam exec` to modify the path for the subcommand. This is
exactly what the various targets in the `Makefile` do.

## The dune build system

Now that we've got our basic package management environment setup, we'll look at how to build our code.
We've already had a glimpse of the `dune` build tool back in [Files Modules And Programs](files-modules-and-programs.html#files-modules-and-programs){data-type=xref}.  Let's check that it's available in your environment after the opam invocations above:

```sh dir=examples/correct/hello-world,unset-INSIDE_DUNE
$ dune --version
2.9.0
```

The root directory of an OCaml project built by dune has a `dune-project` file that defines the project metadata.

```scheme
(lang dune 2.0)
```

The line above is the version of the syntax used in your build files, and not
the actual version of the Dune binary.  One of the nicest features of dune is that
it is forwards-compatible with older metadata. By defining the version of
the dune language that you are currently using, _future_ versions of dune will do their best to emulate the current behaviour until you chose to upgrade your project.

After the version information above, the `dune-project` file defines other useful project metadata.

```scheme
(name hello)
(documentation "https://username.github.io/hello/")
(source (github username/hello))
(license ISC)
(authors "Your name")
(maintainers "Your name")
(generate_opam_files true)
```

The fields here should look familiar -- they were also present in the `hello.opam` file above.  That's because dune can generate the opam packaging metadata files for you and avoid duplication.  Go ahead and edit the metadata above, and then build the project with:

```
dune build
```

The build command will update the `hello.opam` file in your source tree as well,
keeping it in sync with your changes.

### Structure of an OCaml project

Back in [Files Modules And Programs](files-modules-and-programs.html#files-modules-and-programs){data-type=xref},
we looked at what a simple program with a couple of OCaml modules looks like. Let's now look at the full set of files in our hello-world application to examine a more realistic project structure.

```
├── LICENSE
├── Makefile
├── README.md
├── bin
│   ├── dune
│   ├── main.ml
│   └── main.mli
├── dune
├── dune-project
├── hello.opam
├── lib
│   ├── dune
│   ├── hello.ml
│   └── hello.mli
└── test
    ├── dune
    └── hello_test.ml
```

There are three layers of names used in an OCaml project:

- the individual `ml` and `mli` files each define an *OCaml module*, named after the file. This is what you refer to when writing OCaml code that uses other libraries -- for example, `Hello` is the module defined in our project.
- one or more OCaml modules can be gathered together into an *ocamlfind library*, providing a convenient way to package up some dependencies with a single name -- in this case, the `hello` library. Although this example contains just the single `Hello` module , it is common to have multiple modules per library.
- a set of ocamlfind libraries, binaries and application data can all be gathered together into an *opam package*, in this case `hello.opam`. This is what is installed when you eventually publish the package and another user types in `opam install hello`.

It is important to understand the difference between modules, ocamlfind libraries and opam packages, as you will use each of these at different points of your OCaml coding journey.  In order to keep things tidy, we typically structure our project into subdirectories that contain the modules for a particular library or binary, with each directory containing a `dune` file with build instructions.  In our hello world example, we have:

- a `lib/` directory that builds a `hello` ocamlfind library.
- a `test/` directory that defines unit tests for the library.
- a `bin/` directory that uses the `hello` library to build a standalone application that can be executed from the command-line.

### Defining ocamlfind libraries

A project usually puts the business logic of the application into a library rather than directly into an executable binary, since this makes writing tests and documentation easier in addition to improving reusability.  Let's look at `lib/dune` in more detail:

```scheme
(library
 (name hello)
 (public_name hello)
 (libraries))
```

The `(name)` field defines the project-internal name for the compiled library, and the `(public_name)` field is what it will be called when installed system-wide. The choice of `(name)` defines the toplevel module exposed by this library, and every other module in the library will be exposed as a "wrapped" submodule of that toplevel module. In our example project `hello.ml` is exported as the `Hello` module since it's the project name, but if we added a file called `world.ml` into this directory the resulting module would be found in `Hello.World`. While private library names must adhere to OCaml's module naming convention, it's common practise to use dashes and dots in public library names.

### Writing test cases for a library

The `(libraries)` field in the `hello` dune file is empty since this is a standalone library. Our next step is to define a test case in `tests/dune` for our library.

```scheme
(test
 (name hello_test)
 (libraries alcotest hello))
```

The `(test)` field builds an executable binary that is run when you invoke `dune runtest`.  In this case, it uses the `tests/hello_test.ml` module to define the test cases and depends on the external `alcotest` library _and_ the 
locally defined `hello` library.  Once you run the tests, you can find the built artefacts in `_build/default/tests/` in your project checkout.  You can read more about how to define realistic test cases later in [Testing](testing.html){data-type=xref}.

### Building an executable program

Finally, we want to actually use our hello world from the command-line. This is defined in `bin/dune` in a very similar fashion to test cases.

```scheme
(executable
 (name main)
 (public_name hello)
 (libraries hello))
```

Much like libraries, the `(name)` field here has to adhere to OCaml module naming conventions, and the `public_name` field represents the binary name that is installed onto the system and just needs to be a valid Unix or Windows filename.

You can build and execute the command locally using `dune exec` and the public name of the executable:

```sh dir=examples/correct/hello-world
$ dune exec -- hello
Hello world!
```

## Setting up an integrated development environment

Now that we've become familiar with the basic structure of the OCaml project, it's time to setup a development environment. An IDE is particularly useful for OCaml development due to the extra information you can gain from the static type information present in the codebase.  A good IDE will provide you with the facilities to browse interface documentation, see inferred types for code, and to jump to the definitions of external modules.

### Using Visual Studio Code

The recommended IDE for newcomers to OCaml is [Visual Studio Code](https://code.visualstudio.com/), using the [OCaml Platform plugin](https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform).  The plugin uses the Language Server Protocol to communicate with your opam and dune build environment, and you can install the OCaml server via opam:

```
opam install ocaml-lsp-server
```

### Browsing interface documentation

The OCaml LSP server understands how to interface with dune and examine the built artefacts, so opening your local project in VS Code is sufficient to activate all the features.  Try navigating over to `bin/main.ml`, where you will see the invocation to the `hello` library.

<!-- $MDX file=examples/correct/hello-world/bin/main.ml -->
```
let () =
  let greeting = Hello.greet "world" in
  print_endline greeting
```

If you hover your mouse over the `Hello.greet` function, you should see some documentation pop up about the function and its arguments.  This information comes from the _docstrings_ written into the `hello.mli` interface file in the library.

<!-- $DISABLEDMDX file=examples/correct/hello-world/lib/hello.mli -->
```
(** This is a docstring, as it starts with "(**", as opposed to normal comments
    that start with "(*".

    The top-most docstring of the module should contain a description of the
    module, what it does, how to use it, etc.

    The function-specific documentation located below the function signatures. *)

val greet : string -> string
(** This is the docstring for the [greet] function.

    A typical documentation for this function would be:

    Returns a greeting message.

    {4 Examples}

    {[ print_endline @@ greet "Jane" ]} *)
```

## Publishing your code online

### Pushing to GitHub

### Setting up Continuous Integration

GitHub Actions
- Use setup-ocaml


A note on production binaries using DUNE_RELEASE

- edit note: “The warnings used for building” should now mention the dune ones not the core build ones
- result.t is meant to address this deficiency” -> talk about `results instead


