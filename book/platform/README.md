# The OCaml Platform

Every language, no matter how elegant, also needs a set of tools for the
working programmer to deal with editing, compiling, testing, documenting and
publishing your source code. The OCaml community has adopted a platform of
modern tools that help you specify your project metadata and interface it with
IDEs (such as Visual Studio Code), to generate API documentation, and also to
adopt modern software engineering practises such as continuous integration (CI)
and fuzz testing.

Now that you are familiar with the core OCaml language, this second part of the
book will covers tools and techniques for using OCaml at a larger scale.  We
will begin by illustrating the typical structure for an OCaml project and how
you might get started.


## A Hello World OCaml Project

Let's start by creating a sample OCaml project and navigating around it.  opam
provides a project generator known as `spin` that can be used to create various
types of projects.

```sh dir=examples/correct/opam-spin-ls
$ opam spin ls

  bin
    Native project containing a binary

  c-bindings
    Bindings to a C library

  cli
    Command Line Interface releasable on Opam

  js
    Javascript application with Js_of_ocaml

  lib
    Library releasable on Opam

  ppx
    PPX library

```

Before we dive into any of these, we'll generate a tutorial using Spin's built-in
hello world project.

<!-- ```sh dir=examples/correct/opam-spin-hello
TODO need a way to stop spin from running the opam install commands
 -->

```
$ opam spin hello hello-world -vvv

🏗️  Creating a new project from hello in hello-world
Done!

🎁  Installing packages globally. This might take a couple minutes.
```

Spin will create a `hello-world` directory and populate it with a skeleton
OCaml project. Let's have a look around to see what has been generated.

```sh dir=examples/correct/hello-world
$ ls -A1
.gitignore
.ocamlformat
LICENSE
Makefile
README.md
bin
dune
dune-project
hello.opam
lib
test
```

Some of the files generated may be familiar to you from using other programming
languages:

- the `.gitignore` file contains the patterns for generated files from the OCaml
  tools so that they can be ignored by the Git version control software.
  If you're not familiar with using Git, look over one of the tutorials
  one such as GitHub's [git hello world](https://guides.github.com/activities/hello-world/).
- the `Makefile` contains targets for common actions such as `all`, `build`, `test`
  or `clean`.  It's useful to read through this to see which underlying OCaml tools
  are being invoked.
- the `LICENSE` defines the terms under which your code is made available, and
  defaults to the permissive ISC license.
- a `README.md` is a Markdown-formatted introduction to your library or application.

The only metadata file that is really _required_ to participate in
the OCaml ecosystem is an `opam` file in your source tree.  Each `opam`
file defines a collection of OCaml libraries and executable binaries or application
data.  Each `opam` file can define dependencies on other packages, and includes
build and testing directions.  Let's look at the `hello.opam` file:

```sh dir=examples/correct/hello-world
$ cat hello.opam
# This file is generated by dune, edit dune-project instead
opam-version: "2.0"
synopsis: "A short description of the project"
description: "A short description of the project"
maintainer: ["Your name"]
authors: ["Your name"]
license: "ISC"
homepage: "https://github.com/username/hello"
doc: "https://username.github.io/hello/"
bug-reports: "https://github.com/username/hello/issues"
depends: [
  "ocaml" {>= "4.08.0"}
  "dune"
  "alcotest" {with-test}
  "odoc" {with-doc}
]
build: [
  ["dune" "subst"] {pinned}
  [
    "dune"
    "build"
    "-p"
    name
    "-j"
    jobs
    "@install"
    "@runtest" {with-test}
    "@doc" {with-doc}
  ]
]
dev-repo: "git+https://github.com/username/hello.git"
```

The fields in here all represent metadata that describes your project, ranging
from textual descriptions to project URLs.  The `depends` field refers to other
opam packages in the ecosystem.
A collection of `opam` files can be stored in an
*opam repository* to create a package database, with a central one for the OCaml
ecosystem available at <https://github.com/ocaml/opam-repository>.
The official (but not exclusive) tool used for manipulating `opam` files is the
eponymous [opam package manager](https://opam.ocaml.org).  For the purposes of this
chapter, make sure you have a basic installation of opam on your system.

We can now use opam to install the dependencies required for our hello world project.

<!-- ```sh dir=examples/correct/hello-world -->

```
$ make deps
```

This will invoke the opam CLI to install the project dependencies and some useful
tools.  opam doesn't require any special user permissions and stores all of the 
files it installs in `~/.opam` (for global installations) and `_opam` in the
working directory for the project-local installations.  You can use `opam env`
to add the right directories to your local shell path:

```
$ eval $(opam env)
```

If you prefer not to modify your shell configuration, then you can also invoke
the build commands via `opam exec` to modify the path for the subcommand. This is
exactly what the various targets in the `Makefile` do.  The build tool of choice
for the remainder of this book (and indeed, the recommended one for all your OCaml
coding needs) is the `dune` build system.  Let's check that it's available for you.

```sh dir=examples/correct/hello-world,unset-INSIDE_DUNE
$ dune --version
2.9.0
```


## Setting up an integrated development environment

Visual Studio Code

## Setting up continuous integration

GitHub Actions
- Use setup-ocaml


A note on production binaries using DUNE_RELEASE

- edit note: “The warnings used for building” should now mention the dune ones not the core build ones
- result.t is meant to address this deficiency” -> talk about `results instead


